/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * My Title
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://localhost:5001".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {        
        this.configuration = configuration;
        this.basePath = configuration.basePath || this.basePath;        
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: string;
    constructor(public field: string, msg?: string) {
        super(msg);
        this.name = "RequiredError";
    }
}

/**
 * 
 * @export
 * @interface AlignmentDto
 */
export interface AlignmentDto {
    /**
     * 
     * @type {number}
     * @memberof AlignmentDto
     */
    left: number;
    /**
     * 
     * @type {number}
     * @memberof AlignmentDto
     */
    right: number;
    /**
     * 
     * @type {number}
     * @memberof AlignmentDto
     */
    scale: number;
    /**
     * 
     * @type {number}
     * @memberof AlignmentDto
     */
    angle: number;
}

/**
 * 
 * @export
 * @interface FragmentDetailsDto
 */
export interface FragmentDetailsDto {
    /**
     * 
     * @type {string}
     * @memberof FragmentDetailsDto
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof FragmentDetailsDto
     */
    name?: string;
    /**
     * 
     * @type {ScanImageInfoDto}
     * @memberof FragmentDetailsDto
     */
    frontScan?: ScanImageInfoDto;
    /**
     * 
     * @type {ScanImageInfoDto}
     * @memberof FragmentDetailsDto
     */
    backScan?: ScanImageInfoDto;
    /**
     * 
     * @type {ScanImageInfoDto}
     * @memberof FragmentDetailsDto
     */
    frontScanWithoutBackground?: ScanImageInfoDto;
    /**
     * 
     * @type {ScanImageInfoDto}
     * @memberof FragmentDetailsDto
     */
    backScanWithoutBackground?: ScanImageInfoDto;
    /**
     * 
     * @type {AlignmentDto}
     * @memberof FragmentDetailsDto
     */
    frontToBackAlignment?: AlignmentDto;
}

/**
 * 
 * @export
 * @interface ScanImageInfoDto
 */
export interface ScanImageInfoDto {
    /**
     * 
     * @type {string}
     * @memberof ScanImageInfoDto
     */
    originalImageID?: string;
    /**
     * 
     * @type {string}
     * @memberof ScanImageInfoDto
     */
    largeImageID?: string;
    /**
     * 
     * @type {string}
     * @memberof ScanImageInfoDto
     */
    mediumImageID?: string;
    /**
     * 
     * @type {string}
     * @memberof ScanImageInfoDto
     */
    smallImageID?: string;
}

/**
 * 
 * @export
 * @interface WeatherForecast
 */
export interface WeatherForecast {
    /**
     * 
     * @type {string}
     * @memberof WeatherForecast
     */
    dateFormatted?: string;
    /**
     * 
     * @type {number}
     * @memberof WeatherForecast
     */
    temperatureC: number;
    /**
     * 
     * @type {string}
     * @memberof WeatherForecast
     */
    summary?: string;
    /**
     * 
     * @type {number}
     * @memberof WeatherForecast
     */
    temperatureF: number;
}


/**
 * FragmentApi - fetch parameter creator
 * @export
 */
export const FragmentApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} imageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fragmentFetchImage(imageId: string, options: any = {}): FetchArgs {
            // verify required parameter 'imageId' is not null or undefined
            if (imageId === null || imageId === undefined) {
                throw new RequiredError('imageId','Required parameter imageId was null or undefined when calling fragmentFetchImage.');
            }
            const localVarPath = `/api/fragment/image/{imageId}`
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [name] 
         * @param {any} [frontScan] 
         * @param {any} [backScan] 
         * @param {any} [frontScanWithoutBackground] 
         * @param {any} [backScanWithoutBackground] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fragmentIndex(name?: string, frontScan?: any, backScan?: any, frontScanWithoutBackground?: any, backScanWithoutBackground?: any, options: any = {}): FetchArgs {
            const localVarPath = `/api/fragment`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (name !== undefined) {
                localVarQueryParameter['Name'] = name;
            }

            if (frontScan !== undefined) {
                localVarFormParams.set('FrontScan', frontScan as any);
            }

            if (backScan !== undefined) {
                localVarFormParams.set('BackScan', backScan as any);
            }

            if (frontScanWithoutBackground !== undefined) {
                localVarFormParams.set('FrontScanWithoutBackground', frontScanWithoutBackground as any);
            }

            if (backScanWithoutBackground !== undefined) {
                localVarFormParams.set('BackScanWithoutBackground', backScanWithoutBackground as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} fragmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fragmentIndex2(fragmentId: string, options: any = {}): FetchArgs {
            // verify required parameter 'fragmentId' is not null or undefined
            if (fragmentId === null || fragmentId === undefined) {
                throw new RequiredError('fragmentId','Required parameter fragmentId was null or undefined when calling fragmentIndex2.');
            }
            const localVarPath = `/api/fragment/{fragmentId}`
                .replace(`{${"fragmentId"}}`, encodeURIComponent(String(fragmentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fragmentIndexAll(options: any = {}): FetchArgs {
            const localVarPath = `/api/fragment`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FragmentApi - functional programming interface
 * @export
 */
export const FragmentApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} imageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fragmentFetchImage(imageId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = FragmentApiFetchParamCreator(configuration).fragmentFetchImage(imageId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [name] 
         * @param {any} [frontScan] 
         * @param {any} [backScan] 
         * @param {any} [frontScanWithoutBackground] 
         * @param {any} [backScanWithoutBackground] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fragmentIndex(name?: string, frontScan?: any, backScan?: any, frontScanWithoutBackground?: any, backScanWithoutBackground?: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = FragmentApiFetchParamCreator(configuration).fragmentIndex(name, frontScan, backScan, frontScanWithoutBackground, backScanWithoutBackground, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} fragmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fragmentIndex2(fragmentId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FragmentDetailsDto> {
            const localVarFetchArgs = FragmentApiFetchParamCreator(configuration).fragmentIndex2(fragmentId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fragmentIndexAll(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<FragmentDetailsDto>> {
            const localVarFetchArgs = FragmentApiFetchParamCreator(configuration).fragmentIndexAll(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * FragmentApi - factory interface
 * @export
 */
export const FragmentApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} imageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fragmentFetchImage(imageId: string, options?: any) {
            return FragmentApiFp(configuration).fragmentFetchImage(imageId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [name] 
         * @param {any} [frontScan] 
         * @param {any} [backScan] 
         * @param {any} [frontScanWithoutBackground] 
         * @param {any} [backScanWithoutBackground] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fragmentIndex(name?: string, frontScan?: any, backScan?: any, frontScanWithoutBackground?: any, backScanWithoutBackground?: any, options?: any) {
            return FragmentApiFp(configuration).fragmentIndex(name, frontScan, backScan, frontScanWithoutBackground, backScanWithoutBackground, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} fragmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fragmentIndex2(fragmentId: string, options?: any) {
            return FragmentApiFp(configuration).fragmentIndex2(fragmentId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fragmentIndexAll(options?: any) {
            return FragmentApiFp(configuration).fragmentIndexAll(options)(fetch, basePath);
        },
    };
};

/**
 * FragmentApi - object-oriented interface
 * @export
 * @class FragmentApi
 * @extends {BaseAPI}
 */
export class FragmentApi extends BaseAPI {
    /**
     * 
     * @param {string} imageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FragmentApi
     */
    public fragmentFetchImage(imageId: string, options?: any) {
        return FragmentApiFp(this.configuration).fragmentFetchImage(imageId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [name] 
     * @param {any} [frontScan] 
     * @param {any} [backScan] 
     * @param {any} [frontScanWithoutBackground] 
     * @param {any} [backScanWithoutBackground] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FragmentApi
     */
    public fragmentIndex(name?: string, frontScan?: any, backScan?: any, frontScanWithoutBackground?: any, backScanWithoutBackground?: any, options?: any) {
        return FragmentApiFp(this.configuration).fragmentIndex(name, frontScan, backScan, frontScanWithoutBackground, backScanWithoutBackground, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} fragmentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FragmentApi
     */
    public fragmentIndex2(fragmentId: string, options?: any) {
        return FragmentApiFp(this.configuration).fragmentIndex2(fragmentId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FragmentApi
     */
    public fragmentIndexAll(options?: any) {
        return FragmentApiFp(this.configuration).fragmentIndexAll(options)(this.fetch, this.basePath);
    }

}

/**
 * SampleDataApi - fetch parameter creator
 * @export
 */
export const SampleDataApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [startDateIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sampleDataWeatherForecasts(startDateIndex?: number, options: any = {}): FetchArgs {
            const localVarPath = `/api/SampleData/WeatherForecasts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (startDateIndex !== undefined) {
                localVarQueryParameter['startDateIndex'] = startDateIndex;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SampleDataApi - functional programming interface
 * @export
 */
export const SampleDataApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [startDateIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sampleDataWeatherForecasts(startDateIndex?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<WeatherForecast>> {
            const localVarFetchArgs = SampleDataApiFetchParamCreator(configuration).sampleDataWeatherForecasts(startDateIndex, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SampleDataApi - factory interface
 * @export
 */
export const SampleDataApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {number} [startDateIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sampleDataWeatherForecasts(startDateIndex?: number, options?: any) {
            return SampleDataApiFp(configuration).sampleDataWeatherForecasts(startDateIndex, options)(fetch, basePath);
        },
    };
};

/**
 * SampleDataApi - object-oriented interface
 * @export
 * @class SampleDataApi
 * @extends {BaseAPI}
 */
export class SampleDataApi extends BaseAPI {
    /**
     * 
     * @param {number} [startDateIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SampleDataApi
     */
    public sampleDataWeatherForecasts(startDateIndex?: number, options?: any) {
        return SampleDataApiFp(this.configuration).sampleDataWeatherForecasts(startDateIndex, options)(this.fetch, this.basePath);
    }

}

